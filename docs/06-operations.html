<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>GEOG0030</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./11-data.html" rel="next">
<link href="./05-spatial.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>


<link rel="stylesheet" href="assets/styles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./06-operations.html">Core Spatial Analysis</a></li><li class="breadcrumb-item"><a href="./06-operations.html">Analysing Spatial Patterns I: Geometric Operations and Spatial Queries</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./assets/logo.svg" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/jtvandijk/GEOG0030" rel="" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
    <div id="quarto-search" class="quarto-navigation-tool px-1" title="Search"></div>
</div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Module overview</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00-index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Foundational Concepts</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1 Geocomputation: An Introduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-GIScience.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2 GIScience and GIS software</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-cartography.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3 Cartography and Visualisation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-statistics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4 Programming for Data Analysis</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-spatial.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5 Programming for Spatial Analysis</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Core Spatial Analysis</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-operations.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">6 Analysing Spatial Patterns I: Geometric Operations and Spatial Queries</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text">Advanced Spatial Analysis</span></span>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true">
 <span class="menu-text">Additional Resources</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">11 Data Sources</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#analysing-spatial-patterns-i-geometric-operations-and-spatial-queries" id="toc-analysing-spatial-patterns-i-geometric-operations-and-spatial-queries" class="nav-link active" data-scroll-target="#analysing-spatial-patterns-i-geometric-operations-and-spatial-queries"><span class="header-section-number">6</span> Analysing Spatial Patterns I: Geometric Operations and Spatial Queries</a>
  <ul class="collapse">
  <li><a href="#slides-w06" id="toc-slides-w06" class="nav-link" data-scroll-target="#slides-w06"><span class="header-section-number">6.1</span> Lecture slides</a></li>
  <li><a href="#reading-w06" id="toc-reading-w06" class="nav-link" data-scroll-target="#reading-w06"><span class="header-section-number">6.2</span> Reading list</a></li>
  <li><a href="#bike-theft-w06" id="toc-bike-theft-w06" class="nav-link" data-scroll-target="#bike-theft-w06"><span class="header-section-number">6.3</span> Bike theft in London</a>
  <ul class="collapse">
  <li><a href="#setup-w05" id="toc-setup-w05" class="nav-link" data-scroll-target="#setup-w05"><span class="header-section-number">6.3.1</span> Spatial analysis set up</a></li>
  <li><a href="#data-preparation-w06" id="toc-data-preparation-w06" class="nav-link" data-scroll-target="#data-preparation-w06"><span class="header-section-number">6.3.2</span> Data preparation</a></li>
  </ul></li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/jtvandijk/GEOG0030/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">



<section id="analysing-spatial-patterns-i-geometric-operations-and-spatial-queries" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">6</span> Analysing Spatial Patterns I: Geometric Operations and Spatial Queries</h1>
<p>This week, we will be looking at the use of geometric operations and spatial queries within spatial data processing and analysis. Geometric operations and spatial queries are not really a theoretical topic per se but rather essential building blocks to overall spatial data processing and analysis such as calculating the area covered by an individual polygon in an areal unit dataset to running <strong>buffer</strong> and <strong>point-in-polygon</strong> calculations.</p>
<section id="slides-w06" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="slides-w06"><span class="header-section-number">6.1</span> Lecture slides</h2>
<p>The slides for this week’s lecture can be downloaded here: <a href="https://github.com/jtvandijk/GEOG0030/tree/master/slides/w06-geo.pdf">[Link]</a></p>
</section>
<section id="reading-w06" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="reading-w06"><span class="header-section-number">6.2</span> Reading list</h2>
<section id="essential-readings" class="level4">
<h4 class="anchored" data-anchor-id="essential-readings">Essential readings</h4>
<ul>
<li>Lovelace, R., Nowosad, J. and Muenchow, J. 2021. Geocomputation with R, <strong>Chapter 4</strong>: <em>Spatial data operations</em>. <a href="https://geocompr.robinlovelace.net/spatial-operations.html">[Link]</a></li>
<li>Lovelace, R., Nowosad, J. and Muenchow, J. 2021. Geocomputation with R, <strong>Chapter 5</strong>: <em>Geometry operations</em>. <a href="https://geocompr.robinlovelace.net/geometry-operations.html">[Link]</a></li>
<li>Lovelace, R., Nowosad, J. and Muenchow, J. 2021. Geocomputation with R, <strong>Chapter 6</strong>: <em>Reprojecting geographic data</em>. <a href="https://geocompr.robinlovelace.net/reproj-geo-data.html">[Link]</a></li>
</ul>
</section>
<section id="suggested-readings" class="level4">
<h4 class="anchored" data-anchor-id="suggested-readings">Suggested readings</h4>
<ul>
<li>Houlden, V. <em>et al.</em> 2019. A spatial analysis of proximate greenspace and mental wellbeing in London. <em>Applied Geography</em> 109: 102036. <a href="https://doi.org/10.1016/j.apgeog.2019.102036">[Link]</a></li>
<li>Malleson, N. and Andresen, M. 2016. Exploring the impact of ambient population measures on London crime hotspots. <em>Journal of Criminal Justice</em> 46: 52-63. <a href="https://doi.org/10.1016/j.jcrimjus.2016.03.002">[Link]</a></li>
</ul>
</section>
</section>
<section id="bike-theft-w06" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="bike-theft-w06"><span class="header-section-number">6.3</span> Bike theft in London</h2>
<p>This week, we will be investigating bike theft in London in 2021 and look to confirm the hypothesis <em>that bike theft primarily occurs near tube and train stations.</em> We will be investigating its distribution across London using the point data provided within our crime dataset. We will then compare this distribution to the location of train and tube stations using specific geometric operations and spatial queries that can compare the geometry of two (or more) datasets. We will also learn how to download data from OpenStreetMap as well as use an interactive version of <code>tmap</code> to explore the distribution of the locations of individual bike theft against the locations of these stations.</p>
<section id="setup-w05" class="level3" data-number="1.3.1">
<h3 data-number="1.3.1" class="anchored" data-anchor-id="setup-w05"><span class="header-section-number">6.3.1</span> Spatial analysis set up</h3>
<p>Open a new script within your GEOG0030 project and save this script as <code>wk6-bike-theft-analysis.r</code>. At the top of your script, add the following metadata:</p>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-script-title_63d3af0731cf92e0251aa89361728dc7">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Analysing bike theft in London using geometric analysis</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Date: January 2024</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Author: Justin </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now let us add all of the libraries we will be using today to the top of our script:</p>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-load-libraries_a8dec545e86031ebee2e0f8ad0a2aced">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># load libraries</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sf)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tmap)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(osmdata)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div class="cell" data-hash="06-operations_cache/html/06-load-libraries-bg_8b878cdf3b996a5ebe4dfceb141e9d86">
<div class="cell-output cell-output-stderr">
<pre><code>── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──
✔ ggplot2 3.4.0      ✔ purrr   0.3.5 
✔ tibble  3.1.8      ✔ dplyr   1.0.10
✔ tidyr   1.2.1      ✔ stringr 1.5.0 
✔ readr   2.1.3      ✔ forcats 0.5.2 
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE

Data (c) OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright</code></pre>
</div>
</div>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-tmap-settings_bc68f466e3e5d21205d529629112a172">

</div>
<p>This week, we will start off using three datasets: the London MSOA boundaries for 2021, recorded crime in London for 2021 from <a href="https://data.police.uk/">data.police.uk</a>, and the locations of the train and tube stations from <a href="https://tfl.gov.uk/">Transport for London</a>.</p>
<p>We already downloaded the crime data for 2021 during <a href="04-statistics.html#crime-data">Week 4’s computer tutorial</a> and we also saved the 2021 London MSOA boundaries <a href="05-spatial.html#spatial-analysis-set-up">last week</a>, so we only need to download a dataset containing train and tube stations in London.</p>
<section id="file-download" class="level4">
<h4 class="anchored" data-anchor-id="file-download">File download</h4>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: left;">File</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Link</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Train and tube stations in London</td>
<td style="text-align: left;"><code>kml</code></td>
<td style="text-align: left;"><a href="https://github.com/jtvandijk/GEOG0030/tree/master/data/zip/tfl-stations.zip">Download</a></td>
</tr>
</tbody>
</table>
<p>Once downloaded, move your <code>tfl_stations.kml</code> download to your <code>raw</code> data folder and create a new <code>transport</code> folder to contain it. After this, let’s start by loading our London MSOA file:</p>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-load-shp_e7981bd49270ad4793b1cbe9f00442be">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># read in our MSOA GeoPackage</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>msoa_london <span class="ot">&lt;-</span> <span class="fu">st_read</span>(<span class="st">"data/raw/boundaries/MSOA2021_London.gpkg"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Reading layer `MSOA2021_London' from data source 
  `/Users/justinvandijk/Library/CloudStorage/Dropbox/UCL/Web/jtvandijk.github.io/GEOG0030/data/raw/boundaries/MSOA2021_London.gpkg' 
  using driver `GPKG'
Simple feature collection with 1002 features and 4 fields
Geometry type: MULTIPOLYGON
Dimension:     XY
Bounding box:  xmin: 503574.2 ymin: 155850.8 xmax: 561956.7 ymax: 200933.6
Projected CRS: OSGB36 / British National Grid</code></pre>
</div>
</div>
<p>Check the <strong>CRS</strong> of our <code>london_ward_shp</code> spatial dataframe:</p>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-crs-msoapop_78cca707c2ed2dc9e0a8b2592e75bc8e">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># inspect CRS</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">st_crs</span>(msoa_london)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Coordinate Reference System:
  User input: OSGB36 / British National Grid 
  wkt:
PROJCRS["OSGB36 / British National Grid",
    BASEGEOGCRS["OSGB36",
        DATUM["Ordnance Survey of Great Britain 1936",
            ELLIPSOID["Airy 1830",6377563.396,299.3249646,
                LENGTHUNIT["metre",1]]],
        PRIMEM["Greenwich",0,
            ANGLEUNIT["degree",0.0174532925199433]],
        ID["EPSG",4277]],
    CONVERSION["British National Grid",
        METHOD["Transverse Mercator",
            ID["EPSG",9807]],
        PARAMETER["Latitude of natural origin",49,
            ANGLEUNIT["degree",0.0174532925199433],
            ID["EPSG",8801]],
        PARAMETER["Longitude of natural origin",-2,
            ANGLEUNIT["degree",0.0174532925199433],
            ID["EPSG",8802]],
        PARAMETER["Scale factor at natural origin",0.9996012717,
            SCALEUNIT["unity",1],
            ID["EPSG",8805]],
        PARAMETER["False easting",400000,
            LENGTHUNIT["metre",1],
            ID["EPSG",8806]],
        PARAMETER["False northing",-100000,
            LENGTHUNIT["metre",1],
            ID["EPSG",8807]]],
    CS[Cartesian,2],
        AXIS["(E)",east,
            ORDER[1],
            LENGTHUNIT["metre",1]],
        AXIS["(N)",north,
            ORDER[2],
            LENGTHUNIT["metre",1]],
    USAGE[
        SCOPE["Engineering survey, topographic mapping."],
        AREA["United Kingdom (UK) - offshore to boundary of UKCS within 49°45'N to 61°N and 9°W to 2°E; onshore Great Britain (England, Wales and Scotland). Isle of Man onshore."],
        BBOX[49.75,-9,61.01,2.01]],
    ID["EPSG",27700]]</code></pre>
</div>
</div>
<p>Of course it should be of no surprise that our <code>msoa_lon</code> spatial dataframe is in <strong>OSGB36 / British National Grid </strong>, however, it is always good to check. Let’s go ahead and read in our <code>tfl_stations</code> dataset as well:</p>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-load-stations_c12fe446b08071e17904b64686b5c781">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># load stations</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>stations_london <span class="ot">&lt;-</span> <span class="fu">read_sf</span>(<span class="st">"data/raw/transport/tfl_stations.kml"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>This dataset is provided as a <code>kml</code> file, which stands for <strong>Keyhole Markup Language (KML)</strong>. KML was originally created as a file format used to display geographic data in Google Earth. So we definitely need to check what CRS this dataset is in and decide whether we will need to do some reprojecting.</p>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-crs-stations_99cb043ddee42c6439b2b4173b5ed343">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># inspect CRS</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">st_crs</span>(stations_london)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Coordinate Reference System:
  User input: WGS 84 
  wkt:
GEOGCRS["WGS 84",
    DATUM["World Geodetic System 1984",
        ELLIPSOID["WGS 84",6378137,298.257223563,
            LENGTHUNIT["metre",1]]],
    PRIMEM["Greenwich",0,
        ANGLEUNIT["degree",0.0174532925199433]],
    CS[ellipsoidal,2],
        AXIS["geodetic latitude (Lat)",north,
            ORDER[1],
            ANGLEUNIT["degree",0.0174532925199433]],
        AXIS["geodetic longitude (Lon)",east,
            ORDER[2],
            ANGLEUNIT["degree",0.0174532925199433]],
    ID["EPSG",4326]]</code></pre>
</div>
</div>
<p>The result informs us that we are going to need to reproject our data in order to use this dataframe with our <code>msoa_london</code> spatial dataframe. Luckily in <strong>R</strong> and the <code>sf</code> library, this reprojection is a relatively straightforward transformation, requiring only one function: <code>st_transform()</code>. The function is very simple to use: you only need to provide the function with the dataset and the code for the new CRS you wish to use with the data:</p>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-crs-transform_82509a7a795bbcf8dfd74274dcc1b9c9">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># reproject our data from WGS84 to BNG</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>stations_london <span class="ot">&lt;-</span> <span class="fu">st_transform</span>(stations_london, <span class="dv">27700</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We can double-check whether our new variable is in the correct CRS by using the <code>st_crs()</code> command:</p>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-crs-stations-after-trans_6099ef4d25033b39143eccb74f50c0a8">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># inspect CRS</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">st_crs</span>(stations_london)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Coordinate Reference System:
  User input: EPSG:27700 
  wkt:
PROJCRS["OSGB36 / British National Grid",
    BASEGEOGCRS["OSGB36",
        DATUM["Ordnance Survey of Great Britain 1936",
            ELLIPSOID["Airy 1830",6377563.396,299.3249646,
                LENGTHUNIT["metre",1]]],
        PRIMEM["Greenwich",0,
            ANGLEUNIT["degree",0.0174532925199433]],
        ID["EPSG",4277]],
    CONVERSION["British National Grid",
        METHOD["Transverse Mercator",
            ID["EPSG",9807]],
        PARAMETER["Latitude of natural origin",49,
            ANGLEUNIT["degree",0.0174532925199433],
            ID["EPSG",8801]],
        PARAMETER["Longitude of natural origin",-2,
            ANGLEUNIT["degree",0.0174532925199433],
            ID["EPSG",8802]],
        PARAMETER["Scale factor at natural origin",0.9996012717,
            SCALEUNIT["unity",1],
            ID["EPSG",8805]],
        PARAMETER["False easting",400000,
            LENGTHUNIT["metre",1],
            ID["EPSG",8806]],
        PARAMETER["False northing",-100000,
            LENGTHUNIT["metre",1],
            ID["EPSG",8807]]],
    CS[Cartesian,2],
        AXIS["(E)",east,
            ORDER[1],
            LENGTHUNIT["metre",1]],
        AXIS["(N)",north,
            ORDER[2],
            LENGTHUNIT["metre",1]],
    USAGE[
        SCOPE["Engineering survey, topographic mapping."],
        AREA["United Kingdom (UK) - offshore to boundary of UKCS within 49°45'N to 61°N and 9°W to 2°E; onshore Great Britain (England, Wales and Scotland). Isle of Man onshore."],
        BBOX[49.75,-9,61.01,2.01]],
    ID["EPSG",27700]]</code></pre>
</div>
</div>
<p>You should see that our <code>london_stations</code> spatial dataframe is now in <strong>OSGB36 / British National Grid</strong>. We are now ready to load our final dataset - our collection of <code>csv's</code> that contain the crimedata for London for 2021. We can do this by repeating the steps we took during <a href="04-statistics.html#crime-data">Week 4’s computer tutorial</a>:</p>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-combine-csv_266f51162e7e1b861d51ed8e2b442706">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a list of all csv files in the crime folder</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>all_crime_df <span class="ot">&lt;-</span> <span class="fu">list.files</span>(<span class="at">path =</span> <span class="st">"data/raw/crime/all-crime/"</span>, <span class="at">full.names =</span> <span class="cn">TRUE</span>, <span class="at">recursive =</span> <span class="cn">TRUE</span>) <span class="sc">|&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># apply the read_csv() function on each of these files</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lapply</span>(read_csv) <span class="sc">|&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># combine ('bind') them all together into one</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">bind_rows</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Now we have loaded all crime data again, we want to do three things:</p>
<ol type="1">
<li>Extract only those crimes that are bicycle thefts.</li>
<li>Convert our <code>csv</code> into a spatial dataframe that shows the locations of our crimes, as per the latitude and longitudes provided.</li>
<li>Transform our data from <strong>WGS84 / 4326</strong> to <strong>BNG / 27700</strong>.</li>
</ol>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-bike-theft_de4ccd675dc2d5affa4027506d033fea">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># filter all crimes by bicycle thefts only</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>bike_theft <span class="ot">&lt;-</span> all_crime_df <span class="sc">|&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># filter according to crime type, filter out crimes with no location data</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="st">`</span><span class="at">Crime type</span><span class="st">`</span> <span class="sc">==</span> <span class="st">"Bicycle theft"</span> <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">is.na</span>(Longitude) <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">is.na</span>(Latitude)) <span class="sc">|&gt;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># only keep the longitude and latitude columns</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(Longitude, Latitude) <span class="sc">|&gt;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># transform into a point spatial dataframe, projected in WGS84</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_as_sf</span>(<span class="at">coords =</span> <span class="fu">c</span>(<span class="st">"Longitude"</span>, <span class="st">"Latitude"</span>), <span class="at">crs =</span> <span class="dv">4236</span>) <span class="sc">|&gt;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># transform into BNG</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_transform</span>(<span class="dv">27700</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>We now have our three datasets loaded, it is time for a little data checking. We can see just from our <strong>Environment</strong> window that in total, we have <strong>302</strong> train and tube stations and <strong>20,768</strong> crimes to look at in our analysis. We can double-check the (Attribute) tables of our newly created spatial dataframes to see what data we have to work with. You can either do this manually by clicking on the variable, or using commands such as <code>head()</code>, <code>summary()</code> and <code>names()</code> to get an understanding of our dataframe structures and the field names present.You can choose your approach, but make sure to look at your data.</p>
<p>As you should remember from the code above, for our bicycle theft data, we actually only have our geometry column because this is all that we extracted from our collection of crime <code>csv's</code>. For our <code>stations_london</code> spatial dataframe, we have a little more information, including the name of the station, its address, and as its geometry.</p>
<p>Now, let’s map all three layers of data onto a single map using <code>tmap</code>:</p>
<div class="cell" data-hash="06-operations_cache/html/fig-map-all-input_5b6fc2cabdba1b704945cd2b2b4b4190">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plot our London MSOAs</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tm_shape</span>(msoa_london) <span class="sc">+</span> <span class="fu">tm_fill</span>() <span class="sc">+</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># then add bike crime</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tm_shape</span>(bike_theft) <span class="sc">+</span> <span class="fu">tm_dots</span>(<span class="at">col =</span> <span class="st">"blue"</span>) <span class="sc">+</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># then add stations</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tm_shape</span>(stations_london) <span class="sc">+</span> <span class="fu">tm_dots</span>(<span class="at">col =</span> <span class="st">"red"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell-output-display">
<div id="fig-map-all-input" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="06-operations_files/figure-html/fig-map-all-input-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Figure&nbsp;1: Quick thematic map.</figcaption>
</figure>
</div>
</div>
</div>
<p>Let’s think about the distribution of our data: we can already see that our bike theft is clearly highly concentrated in the centre of London although we can certainly see some clusters in other areas. Let’s go ahead and temporally remove the bike theft data from our map for now to see where our tube and train stations are located.</p>
<p>To remove the bike data, simply put a comment sign in front of that piece of code and re-run the code:</p>
<div class="cell" data-hash="06-operations_cache/html/fig-map-all-input-no-bike_f1a6c0185bf344d11a33f2e1174cf30a">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plot our London MSOAs</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tm_shape</span>(msoa_london) <span class="sc">+</span> <span class="fu">tm_fill</span>() <span class="sc">+</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># then add bike crime</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># tm_shape(bike_theft) + tm_dots(col = "blue") +</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># then addstations</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tm_shape</span>(stations_london) <span class="sc">+</span> <span class="fu">tm_dots</span>(<span class="at">col =</span> <span class="st">"red"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell-output-display">
<div id="fig-map-all-input-no-bike" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="06-operations_files/figure-html/fig-map-all-input-no-bike-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Figure&nbsp;2: Quick thematic map.</figcaption>
</figure>
</div>
</div>
</div>
<p>We can see our train and tube stations are only present in primarily the north of London and not really present in the south. This is not quite right and in fact our dataset only contains those train stations used by Transport for London within the tube network rather than all the stations in London. We will need to fix this before conducting our full analysis. But this isn’t the only problem with our dataset. We can also see that both our <code>bike_theft</code> spatial dataframe and our <code>stations_london</code> spatial dataframe extend beyond our London boundaries.</p>
</section>
</section>
<section id="data-preparation-w06" class="level3" data-number="1.3.2">
<h3 data-number="1.3.2" class="anchored" data-anchor-id="data-preparation-w06"><span class="header-section-number">6.3.2</span> Data preparation</h3>
<p>When we want to reduce a dataset to the spatial extent of another, there are two different approaches to conducting this in spatial analysis: a subset or a clip. Each deal with the geometry of the resulting dataset in slightly different ways.</p>
<ol type="1">
<li>A <em>clip-type operation</em> works a bit like a cookie-cutter: it will take the geometry of the input layer (i.e.&nbsp;the layer you want to clip), places a ‘cookie-cutter’ layer on top (i.e.&nbsp;the layer you want to clip by) and then returns only the parts of the input layer contained within the cookie-cutter. This will mean that the geometry of our resulting layer will be modified, if it contains observation features that extend further than the ;cookie-cutter’ extent it will literally ‘cut’ the geometry of our data.</li>
<li>A subset-type operation is what is known in GIScience-speak as a <em>select by location query</em>. In this case, our subset will return the full geometry of each observation feature of the input layer that intersects with our second layer. Any geometry that does not intersect with our second layer will be removed from the geometry of our resulting layer.</li>
</ol>
<div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Because we are using point data, we can use either approach because it is not possible to split the geometry of a single point feature. When it comes to polygon and line data, not understanding the differences between the two approaches can lead you into difficulties with your data processing as there will be differences in the feature geometry between the clipped layer and the subset layer.</p>
</div>
</div>
</div>
<p>Each approach is implemented differently in R. To <strong>subset</strong> our data, we only need to use the <code>base</code> R library to selection using <code>[]</code> brackets:</p>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-subset-ldn-bt_493894ed4711f5ff3e85187a9a7b2694">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># subset</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>bike_theft <span class="ot">&lt;-</span> bike_theft[msoa_london, ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>If we want to <strong>clip</strong> our data, we need to use the <code>st_intersection()</code> function from the <code>sf</code> library.</p>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-clip-ldn-bt_15be6097de831b7e278ba94b8b17dded">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># clip</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>bike_theft <span class="ot">&lt;-</span> bike_theft <span class="sc">|&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">st_intersection</span>(msoa_london)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: attribute variables are assumed to be spatially constant throughout all
geometries</code></pre>
</div>
</div>
<div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Out of the two, the <strong>subset</strong> approach is the fastest to use as R is simply comparing the geometries rather than also editing the geometries, but which approach you use with future data is always dependent on your data and the output you need.</p>
</div>
</div>
</div>
<p>Before we go ahead and sort out our <code>london_stations</code> spatial dataframe, we are going to look at how we can <strong>dissolve</strong> our <code>msoa_london</code> spatial dataframe into a single feature. Reducing a spatial dataframe to a single observation is often required when using R and <code>sf</code>‘s geometric operations to complete geometric comparisons. Sometimes, also, we simply want to map an outline of an area, such as London, rather than add in the additional spatial complexities of our wards. To achieve just a single ’observation’ that represents the <strong>outline geometry</strong> of our dataset, we use the geometric operation <code>st_union()</code>.</p>
<div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>You can also use the <code>st_union()</code> function to combine two datasets into one. This can be used to <strong>merge</strong> data together that are of the same spatial type.</p>
</div>
</div>
</div>
<div class="cell styled-output" data-hash="06-operations_cache/html/06-union-ldn-bt_48b2277d5287d281baa1e39722b11c56">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># union</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>london_outline <span class="ot">&lt;-</span> msoa_london <span class="sc">|&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">st_union</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>You should see that our <code>london_outline</code> spatial data frame only has one observation. You can now go ahead and <code>plot()</code> your <code>london_outline</code> spatial dataframe from your console and see what it looks like:</p>
<div class="cell" data-hash="06-operations_cache/html/06-union-ldn-plot_725c2ec68db26ab54fd56d850d614e24">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>R code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(london_outline)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="06-operations_files/figure-html/06-union-ldn-plot-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Quick plot of the London outline.</figcaption>
</figure>
</div>
</div>
</div>
<p>Back to our train and tube stations. We have seen that our current <code>london_stations</code> spatial dataframe does not provide the coverage of train stations in London that we expected. To add in our missing data, we will be using <a href="https://www.openstreetmap.org/#map=6/54.910/-3.432">OpenStreetMap</a>.</p>
<div class="callout callout-style-simple callout-note">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>OpenStreetMap (OSM) is a free editable map of the world,although its spatial coverage is still unequal across the world. In addition, as you will find if you use the data, the accuracy and quality of the data can often be quite questionable or simply missing attribute details that we would like to have, e.g.&nbsp;types of roads and their speed limits, to complete specific types of spatial analysis. As a result, do not expect OSM to contain every piece of spatial data that you would want.</p>
</div>
</div>
</div>
<p>Whilst there are <a href="https://wiki.openstreetmap.org/wiki/Downloading_data">various approaches</a> to downloading data from OpenStreetMap, we will use the <code>osmdata</code> library to directly extract our required OpenStreetMap (OSM) data into a variable. The <code>osmdata</code> library grants access within R to the <a href="https://overpass-turbo.eu">Overpass API</a> that allows us to run queries on OSM data and then import the data as either <code>sf</code> or <code>sp</code> objects. These queries are at the heart of these data downloads.</p>
<!-- To use the library (and API), we need to know how to write and run a query, which requires identifying the `key` and `value` that we need within our query to select the correct data. Essentially every map element (whether a point, line or polygon) in OSM is "tagged" with different attribute data. In our case, we are looking for train stations, which fall under the key, `Public Transport`, with a value of `station` as outlined in their [wiki](https://wiki.OpenStreetMap.org/wiki/Key:public_transport). These `keys` and `values` are used in our queries to extract only map elements of that feature type - to find out how a feature is "tagged" in OSM is simply a case of reading through the OSM documentation and [becoming familiar](https://wiki.openstreetmap.org/wiki/Tags) with their `keys` and `values`.  -->
<!-- In addition to this key-value pair, we also need to obtain the **bounding box** of where we want our data to be extracted from, i.e. London, to prevent OSM searching the whole map of the world for our feature (although the API query does have in-built time and spatial coverage limits to stop this from happening). -->
<!-- Let's try to extract elements from OSM that are tagged as `public_transport = station` from OSM into an `osmdata_sf()` object: -->
<!-- ```{r 06-osm-export, warnings=FALSE, message=FALSE, cache=TRUE, tidy='styler'} -->
<!-- # extract the coordinates from our London outline using the st_bbox() function -->
<!-- # note we also temporally reproject the london_outline spatial dataframe before obtaining the bbox -->
<!-- # we need our bbox coordinates in WGS84 (not BNG), hence reprojection -->
<!-- p_bbox <- st_bbox(st_transform(london_outline, 4326)) -->
<!-- # pass our bounding box coordinates into the OverPassQuery (opq) function -->
<!-- london_stations_osm <- opq(bbox = p_bbox) %>% -->
<!--   # pipe this into the add_osm_feature data query function to extract our stations -->
<!--   add_osm_feature(key = "public_transport", value = "station") %>%  -->
<!--   # pipe this into our osmdata_sf object -->
<!--   osmdata_sf() -->
<!-- ```  -->
<!-- :::note -->
<!-- **Note** <br/> -->
<!-- In some instances the OSM query will return an error, especially when several people from the same location are executing the exact same query at the same time. If that is the case you can download the `london_stations_osm` object here: [[Download]](https://github.com/jtvandijk/GEOG0030/tree/master/data/zip/london_stations_osm.RData). After downloading, you can copy the file to your working directory and load the object using the `load()` function. -->
<!-- ::: -->
<!-- :::tip -->
<!-- **Tip** <br/> -->
<!-- When we download OSM data, and extract it as above, our query will return all elements tagged as our key-value pair into our `osmdata_sf()` OSM data object. This means all elements associated with our tag will be returned: any **points, lines and polygons**. We might think with our `public_transport = station` tag, we would only return point data representing our train and tube stations in London. But if we use the `summary()` function on our `london_stations_osm` OSM data object, we can see that not only is a lot of other data stored in our OSM data object (including the bounding box we used within our query, plus metadata about our query), but our query has returned both **points** and **polygons** stored within this OSM data object as individual spatial data frames.  -->
<!-- To extract only the points of our tube and train stations from our `london_stations_osm` OSM data object, we simply need to extract this from the dataframe and store this under a separate variable. But, whenever you are dealing with OSM data, just remember that your query can return multiple different types of map elements (and their respective geometries), so always be clear in knowing which type of spatial data you will need and remember to extract this from your OSM data object. -->
<!-- ::: -->
<!-- Extract train station points from our OSM data object and process/clean ready for analysis: -->
<!-- ```{r 06-osm-stations, warnings=FALSE, message=FALSE, cache=TRUE, tidy='styler'} -->
<!-- # extract only the points data from the osmdata object  -->
<!-- london_stations_osm <- london_stations_osm$osm_points %>%  -->
<!--   # add projection to the point spatial dataframe -->
<!--   st_set_crs(4326) %>% -->
<!--   # reproject our dataset to BNG  -->
<!--   st_transform(27700) %>%   -->
<!--   # clip to the London outline shapefile   -->
<!--   st_intersection(london_outline) %>%  -->
<!--   # select only attributes that seem relevant -->
<!--   dplyr::select(c("osm_id", "name", "network", "operator", "public_transport", "railway")) -->
<!-- # inspect -->
<!-- plot(london_stations_osm) -->
<!-- ``` -->
<!-- With the accuracy of OSM a little questionable, we want to complete some data validation tasks to check its quality and to confirm that it at least contains the data we see in our authoritative `london_stations` spatial dataframe. The total number of data points also seems rather high. In fact, a quick search online can tell us that there are [272 tube stations](https://tfl.gov.uk/corporate/about-tfl/what-we-do) in the London network as well as [335 train stations](https://en.wikipedia.org/wiki/List_of_London_railway_stations) in Greater London. -->
<!-- As we can see in our plot above, not all of our stations appear to be of the same value in our `railway` field. If we check the field using our `count()` function, you will see that there are some different values and `NAs` in our dataset: -->
<!-- ```{r 06-count-stations, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE} -->
<!-- # inspect values -->
<!-- count(london_stations_osm, railway) -->
<!-- ``` -->
<!-- As we can see, not everything in our `london_stations_osm` spatial dataframe is a `station` as recorded by OSM and we have a high number of `NAs` which are unlikely to actually represent stations in London. The number of points marked as `station` in the `railway` field are most likely the only points in our dataset that represent actual stations in London. There is still a difference between the official numbers and the OSM extract, but we will go on and use the best information we have from this attribute and our search and remove all other points from our OSM dataset: -->
<!-- ```{r 06-osm-stations-clean, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE} -->
<!-- # extract only the points that we think are actual train and tube stations -->
<!-- london_stations_osm <- london_stations_osm %>% filter(railway == "station") -->
<!-- ``` -->
<!-- We have now cleaned our `london_stations_osm` spatial dataframe to remove all those points within our dataset that are not tagged as `railway == "station"`. Our `london_stations` spatial dataframe is of course an **authoritative** dataset from TfL, so we know at least that this data should be accurate. Therefore, it would be great if we could compare our two datasets to one another spatially to double-check that our `london_stations_osm` spatial dataframe contains all the data within our `london_stations` spatial dataframe. -->
<!-- We can first look at this by comparing their distributions visually on a map. But first, as our `london_stations` spatial dataframe still extends outside of London, we will go ahead and clip this: -->
<!-- ```{r 06-intersect-ldn-wd, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE} -->
<!-- # clip London stations -->
<!-- london_stations <- london_stations %>% st_intersection(london_ward_shp) -->
<!-- ``` -->
<!-- Map our two spatial dataframes to compare their spatial coverage: -->
<!-- ```{r 06-map-some-data-23, warnings=FALSE, message=FALSE, cache=TRUE, tidy='styler'} -->
<!-- # plot our London Wards first with a grey background -->
<!-- tm_shape(london_outline) + tm_fill() +  -->
<!--     # plot OSM station data in black -->
<!--     tm_shape(london_stations_osm) + tm_dots(col = "black") +  -->
<!--     # plot TfL station data in red -->
<!--     tm_shape(london_stations) + tm_dots(col = "red") +  -->
<!--     # add north arrow -->
<!--     tm_compass(type = "arrow", position = c("right", "bottom")) +  -->
<!--     # add scale bar   -->
<!--     tm_scale_bar(breaks = c(0, 5, 10, 15, 20), position = c("left", "bottom")) + -->
<!--     # add our OSM contributors statement -->
<!--     tm_credits("© OpenStreetMap contributors") -->
<!-- ``` -->
<!-- What we can see is that it looks like our OSM data actual does a much better job at covering all train and tube stations across London but still it is pretty hard to get a sense of comparison from a static map like this whether it contains all of the tube and train stations in our `london_stations` spatial dataframe. An interactive map would enable us to interrogate the spatial coverage of our two station spatial dataframes further. To do so, we use the `tmap_mode()` function and change it from its default `plot()` mode to a `view()` model: -->
<!-- ```{r 06-map-some-data-4, warnings=FALSE, message=FALSE, tidy='styler'} -->
<!-- # change tmap mode to view / interactive mapping -->
<!-- tmap_mode("view") -->
<!-- # plot the outline of our London Wards first -->
<!-- tm_shape(london_outline) + tm_borders() +  -->
<!--     # plot OSM station data in black -->
<!--     tm_shape(london_stations_osm) + tm_dots(col = "black") +  -->
<!--     # plot TfL station data in red -->
<!--     tm_shape(london_stations) + tm_dots(col = "red") + -->
<!--     # set basemap -->
<!--     tm_basemap(c(StreetMap = "OpenStreetMap")) -->
<!-- ``` -->
<!-- Using the interactive map, what we can see is that whilst we **do** have overlap with our datasets, and more importantly, our `london_stations_osm` spatial dataframe seems to contain all of the data within the `london_stations` spatial dataframe, although there are definitely differences in their precise location. Now depending on what level of accuracy we are willing to accept with our assumption that our OSM data contains the **same** data as our Transport for London data, we could leave our comparison here and move forward with our analysis. There are, however, several more steps we could complete to validate this assumption. The easiest first step is to simply reverse the order of our datasets to check that each `london_stations` spatial dataframe point is covered by reversing the drawing order: -->
<!-- ```{r 06-map-some-data-5, warnings=FALSE, message=FALSE, tidy='styler'} -->
<!-- # plot the outline of our London Wards first -->
<!-- tm_shape(london_outline) + tm_borders() +  -->
<!--     # plot TfL station data in red -->
<!--     tm_shape(london_stations) + tm_dots(col = "red") +  -->
<!--     # plot OSM station data in black -->
<!--     tm_shape(london_stations_osm) + tm_dots(col = "black") + -->
<!--     # set basemap -->
<!--     tm_basemap(c(StreetMap = "OpenStreetMap")) -->
<!-- ``` -->
<!-- ### Spatial operations I -->
<!-- The comparision looks pretty good but still the question is: can we be sure? Using geometric operations and spatial queries, we can look to find if any of our stations in our `london_stations` spatial dataframe are not present the `london_stations_osm` spatial dataframe. We can use specific geometric operations and/or queries that let us check whether or not all points within our `london_stations` spatial dataframe spatially intersect with our `london_stations_osm` spatial dataframe, i.e. we can complete the opposite of the clip/intersection that we conducted earlier. The issue we face, however is that, as we saw above, our points are slightly offset from one another as the datasets have ultimately given the same stations slightly different locations. This offset means we need to think a little about the geometric operation or spatial query that we want to use. -->
<!-- We will approach this question in two different ways to highlight the differences between geometric operations and spatial queries: -->
<!-- 1. We will use **geometric operations** to generate geometries that highlight missing stations from our `london_stations` spatial dataframe (i.e. ones that are not present in the`london_stations_osm` spatial dataframe.) -->
<!-- 2. We will use **spatial queries** to provide us with a list of features in our `london_stations` spatial dataframe that do not meet our spatial requirements (i.e. are not present in the`london_stations_osm` spatial dataframe.) -->
<!-- #### Geometric operations -->
<!-- As highlighted above, the offset between our spatial dataframes adds a little complexity to our geometric operations code. To be able to make our direct spatial comparisons across our spatial dataframes, what we first need to do is try to **snap** the geometry of our `london_stations` spatial dataframe to our `london_stations_osm` spatial dataframe for points within a given distance threshold. This will mean that any points in the `london_stations` spatial dataframe that are within a specific distance of the `london_stations_osm` spatial dataframe will have their geometry changed to that of the `london_stations_osm` spatial dataframe. -->
<!-- ```{r 06-snap1, echo=FALSE, fig.align='center', cache=TRUE, fig.cap='Snapping points to a line. In our case we snap our points to other points.'} -->
<!-- knitr::include_graphics('images/w06/snap1.png') -->
<!-- ``` -->
<!-- By placing a threshold on this **snap**, we stop too many points moving about if they are unlikely to be representing the same station (e.g. further than 150m or so away) but this still allows us to create more uniformity across our datasets' geometries (and tries to reduce the uncertainty we add by completing this process). -->
<!-- Snap our our `london_stations` spatial dataframe to our `london_stations_osm` spatial dataframe for points within a 150m distance threshold: -->
<!-- ```{r 06-snap-data, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE} -->
<!-- # snap points  -->
<!-- london_stations_snap <- st_snap(london_stations, london_stations_osm, 150) -->
<!-- ``` -->
<!-- Now we have out snapped geometry, we can look to compare our two datasets to calculate whether or not our `london_stations_osm` spatial dataframe is missing any data from our `london_stations_snap` spatial dataframe.  -->
<!-- To do so, we will use the `st_difference()` function which will return us the geometries of those points in our `london_stations_snap` spatial dataframe that are missing in our our `london_stations_osm` spatial dataframe. However, to use this function successfully we need to convert our our `london_stations_osm` spatial dataframe into a single geometry first. -->
<!-- To simplify our `london_stations_osm` spatial dataframe into a single geometry, we simply use the `st_union()` code we used with our London outline above: -->
<!-- ```{r 06-missing-nodes, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE} -->
<!-- # create a single geometry version of our london_stations_osm spatial dataframe  -->
<!-- london_stations_osm_compare <- london_stations_osm %>% st_union() -->
<!-- # compare our two point geometries to identify missing stations -->
<!-- missing_stations <- st_difference(london_stations_snap, london_stations_osm_compare) -->
<!-- ``` -->
<!-- You should now find that we apparently have **4** missing stations in our `london_stations_osm` spatial dataframe. We can plot these missing stations against our `london_stations_osm` spatial dataframe and confirm whether these stations are indeed missing or not.  -->
<!-- ```{r 06-map-some-data-3, warnings=FALSE, message=FALSE, tidy='styler'} -->
<!-- # plot our london_stations_osm spatial dataframe in black -->
<!-- tm_shape(london_stations_osm) + tm_dots(col = "black") +  -->
<!--   # plot our missing_stations spatial dataframe in green -->
<!--   tm_shape(missing_stations) + tm_dots(col = "green")  + -->
<!--     # set basemap -->
<!--     tm_basemap(c(StreetMap = "OpenStreetMap")) -->
<!-- ``` -->
<!-- <br/> -->
<!-- When you investigate the  missing stations, you can actually see that our `london_stations_osm` spatial dataframe dataset is actually more accurate than the TfL locations. All 'missing' stations are not in fact missing but simply at a greater offset than 150m. We can safely suggest that we can move forward with only using the `london_stations_osm` spatial dataframe and do not need to follow through with adding any more data to this dataset. -->
<!-- #### Spatial queries -->
<!-- Before we go ahead and move forward with our analysis, we will have a look at how we can implement the above quantification using spatial queries instead of geometric operations. Usually, when we want to find out if two spatial dataframes have the same or similar geometries, we would use one of the following queries: -->
<!-- * `st_equals()` -->
<!-- * `st_intersects()` -->
<!-- * `st_crosses()` -->
<!-- * `st_overlaps()` -->
<!-- * `st_touches()` -->
<!-- Ultimately which query or spatial relationship conceptualisation you would choose would depend on the qualifications you are trying to place on your dataset. In our case, considering our `london_stations` spatial dataframe and our `london_stations_osm` spatial dataframe, we have to consider **the offset between our datasets**. We could, of course, *snap* our spatial dataframe as above but wouldn't it be great if we could skip this step?  -->
<!-- To do so, instead of *snapping* the `london_stations` spatial dataframe to the `london_stations_osm` spatial dataframe, we can use the `st_is_within_distance()` spatial query to ask whether our points in our `london_stations` spatial dataframe are within 150m of our `london_stations_osm` spatial dataframe. This ultimately means we can skip the snapping and `st_difference()` steps and complete our processing in two simple steps. -->
<!-- :::tip -->
<!-- **Tip** <br /> -->
<!-- One thing to be aware of when running spatial queries in R and `sf` is that whichever spatial dataframe is the comparison geometry (i.e. spatial dataframe `y` in our queries), this spatial dataframe **must** be a **single geometry** (as we saw above in our `st_difference()` geometric operation). If it is not a single geometry, then the query will be run `x` number of observations * `y` spatial dataframe number of observations times, which is not the output that we want. By converting our comparison spatial dataframe to a single geometry, the query is only run for the number of observations in `x`. -->
<!-- You should also be aware that any of our spatial queries will return **one** of **two potential outputs**: a **list** detailing the **indexes** of all those observation features in `x` that do intersect with `y`, or a **matrix** that contains a `TRUE` or `FALSE` statement about this relationship. To define whether we want a list or a matrix output, we set the `sparse` parameter within our query to `TRUE` or `FALSE` respectively. -->
<!-- ::: -->
<!-- Query whether the points in our `london_stations` spatial dataframe are within 150m of our `london_stations_osm` spatial dataframe: -->
<!-- ```{r 06-missing-nodes-sq, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE} -->
<!-- # create a single geometry version of our `london_stations_osm` spatial dataframe for comparison -->
<!-- london_stations_osm_compare <- london_stations_osm %>% st_union() -->
<!-- # compare our two point geometries to identify missing stations -->
<!-- london_stations$in_osm_data <- st_is_within_distance(london_stations, london_stations_osm_compare, dist=150, sparse=FALSE) -->
<!-- ``` -->
<!-- We can go ahead and `count()` the results of our query. -->
<!-- ```{r 06-missing-nodes-count, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE} -->
<!-- # count the number of stations within 150m of our the OSM spatial dataframe -->
<!-- count(london_stations, in_osm_data) -->
<!-- ``` -->
<!-- Great - we can see we have **4** stations missing (4 `FALSE` observations), just like we had in our geometric operations approach. We can double-check this by mapping our two layers together: -->
<!-- ```{r 06-map-some-data-143, warnings=FALSE, message=FALSE, cache=TRUE, tidy='styler'} -->
<!-- # plot our london_stations by the in_osm_data column -->
<!-- tm_shape(london_stations) + tm_dots(col = "in_osm_data") +  -->
<!--   # add our missing_stations spatial dataframe -->
<!--   tm_shape(missing_stations) + tm_dots(col = "green") + -->
<!--     # set basemap -->
<!--     tm_basemap(c(StreetMap = "OpenStreetMap")) -->
<!-- ``` -->
<!-- You can turn on and off the `missing_stations` layer to compare the locations of these points to the `FALSE` stations within our `london_stations_osm` spatial dataframe, generated by our spatial query.  -->
<!-- #### File export -->
<!-- Now we have done our checks and we know that we can move forward with using our tube and train station file, we should save a copy for usage at a later stage. Save your `london_stations_osm` spatial dataframe under the `transport` folder in your `raw` directory as a shapefile: -->
<!-- ```{r 08-scr-write-out, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE, eval=FALSE} -->
<!-- # write out london_stations_osm to a shapefile -->
<!-- st_write(london_stations_osm, "data/raw/transport/osm_stations.shp") -->
<!-- ``` -->
<!-- ### Spatial operations II -->
<!-- We now have our London bike theft and train stations ready for analysis and we just need to complete one last step of processing with this dataset to find out *whether or not bike theft occurs more often near to a train station*. As above, we can use both geometric operations or spatial queries to complete this analysis. -->
<!-- #### Geometric operations -->
<!-- Our first approach using geometric operations will involve the creation of a **buffer** around each train station to then identify which bike thefts occur within 400m of a train or tube station.  -->
<!-- When it comes to buffers, we need to consider two main things: what distance will we use (and are we in the right CRS to use a buffer) and whether we want individual buffers or a single buffer. -->
<!-- ```{r 06-buffer-buffer, echo=FALSE, fig.align='center', out.width='500pt', cache=TRUE, fig.cap='A single versus multiple buffer. The single buffer represents a dissolved version of the multiple buffer option. Source: Q-GIS, 2020.'} -->
<!-- knitr::include_graphics('images/w06/buffer.png') -->
<!-- ``` -->
<!-- In terms of CRS, we want to make sure we use a CRS that defines its measurement units in metres. If our CRS does not use metres as its measurement unit, it might be in a base unit of an Arc Degree or something else that creates difficulties when converting between a required metre distance and the measurement unit of that CRS. In our case, we are using British National Grid and, luckily for us, the units of the CRS is metres, so we do not need to worry about this. -->
<!-- In terms of determining whether we can create a single or multiple buffers, we can investigate the documentation of the function `st_buffer()` to find out what additional parameters it takes. What we can find out is that we need to (of course!) provide a distance for our buffer, but whatever figure we supply this will be interpreted within the units of the CRS we are using. Fortunately none of this is our concern: we know we can simply input the figure or 400 into our buffer and this will generate a buffer of 400m.  -->
<!-- ```{r 06-buffer-stations, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE} -->
<!-- # generate a 400m buffer around our london_stations_osm dataset, union it to create one buffer -->
<!-- station_400m_buffer <- london_stations_osm %>% st_buffer(dist = 400) %>% st_union() -->
<!-- ``` -->
<!-- You can then go ahead and plot our buffer to see the results, entering `plot(station_400m_buffer)` within the console: -->
<!-- ```{r 06-plot-buffer-stations, warnings=FALSE, message=FALSE, cache=TRUE, echo=FALSE} -->
<!-- # plot buffer -->
<!-- plot(station_400m_buffer) -->
<!-- ``` -->
<!-- To find out which bike thefts have occurred within 400m of a station, we will use the `st_intersects()` function. -->
<!-- :::tip -->
<!-- **Tip** <br /> -->
<!-- Before we move forward, one thing to note is that there is a difference between `st_intersects()` and the `st_intersections()` function we have been used so far. Unlike the `st_intersections()` function which creates a 'clip' of our dataset, i.e. produces a new spatial dataframe containing the clipped geometry, the `st_intersects()` function simply identifies whether "x and y geometry share any space". As explained above, as with all spatial queries, the `st_intersects()` function can produce two different outputs: either a list detailing the **indexes** of all those observation features in `x` that do intersect with `y` or a matrix that contains a `TRUE` or `FALSE` statement about this relationship. As with our previous spatial query, we will continue to use the matrix approach: this means for every single bike theft in London, we will know whether or not it occurred within our chosen distance of a train station. We can then join this as a new column to our `bike_theft_2019` spatial dataframe. -->
<!-- ::: -->
<!-- To detect which bike thefts occur within 400m of a train or tube station, we can do: -->
<!-- ```{r 06-intersect-test, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE} -->
<!-- # test whether a bike theft intersects with our station buffer and store this as a new column called nr_train_400m -->
<!-- bike_theft_2019$nr_train_400 <- bike_theft_2019 %>% st_intersects(station_400m_buffer, sparse=FALSE) -->
<!-- ``` -->
<!-- We could go ahead and recode this to create a `1` or `0`, or `YES` or `NO` after processing, but for now we will leave it as `TRUE` or `FALSE`. We can go ahead and now visualise our `bike_theft_2019` based on this column, to see those occurring near to a train station: -->
<!-- ```{r 06-intersect-map, warnings=FALSE, message=FALSE, cache=TRUE, tidy='styler'} -->
<!-- # set tmap back to drawing mode  -->
<!-- tmap_mode("plot") -->
<!-- # plot our london outline border -->
<!-- tm_shape(london_outline) + tm_borders() +  -->
<!--   # plot our bike theft and visualise the nr_train_400m column -->
<!--   tm_shape(bike_theft_2019) + tm_dots(col = "nr_train_400", palette = "BuGn") + -->
<!--   # add our train stations on top -->
<!--   tm_shape(london_stations_osm) + tm_dots(palette = "gray") + -->
<!--   # add our OSM contributors statement -->
<!--   tm_credits("© OpenStreetMap contributors") -->
<!-- ``` -->
<!-- It should be of no surprise that visually we can of course see some defined clusters of our points around the various train stations. We can then utilise this resulting dataset to calculate the percentage of bike thefts have occured at this distance, but first we will look at the spatial query approach to obtaining the same data. -->
<!-- #### Spatial queries -->
<!-- Like earlier, we can use the `st_is_within_distance()` function to identify those bike thefts that fall within 400m of a tube or train station in London. -->
<!-- We will again need to use the **single geometry** version of our `london_stations_osm` spatial dataframe for this comparison with `sparse = FALSE` to create a matrix that we simply join back to our `bike_theft_2019` spatial dataframe as a new column: -->
<!-- ```{r 06-check-missing-nodes, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE} -->
<!-- # compare our two point geometries to identify missing stations -->
<!-- bike_theft_2019$nr_train_400_sq <- st_is_within_distance(bike_theft_2019, london_stations_osm_compare, dist=400, sparse=FALSE) -->
<!-- ``` -->
<!-- We can `count` or map the outputs of our two different approaches to check that we have the same output. If you were to do this you will see that we have achieved the exact same output with fewer lines of code and, as a result, quicker processing. However, unlike with the geometric operations, we do not have a buffer to visualise this distance around a train station, which we might want to do for maps in a report or presentation, for example. Once again, it will be up to you to determine which approach you prefer to use. Some people prefer using the more visual techniques of **geometric operations**, whereas others might find **spatial queries** to answer the same questions. -->
<!-- #### Theft at train and tube locations? -->
<!-- Now we have, for each bike theft in our `bike_theft_2019` spatial dataframe, an attribute of whether it occurs within 400m of a train or tube station. We can quite quickly use the `count()` function to find out just how many thefts these clusters of theft represent. -->
<!-- ```{r 06-intersect-count, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE} -->
<!-- # count the number of bike thefts occuring 400m within a station -->
<!-- count(bike_theft_2019, nr_train_400) -->
<!-- ``` -->

<!-- Over 40 per cent of bike thefts occur within 400m of a train station - that is quite a staggering amount, but if we consider commuter behaviour this occurrence is not be unexpected. After all, if a bike is left at a train station, it is unlikely to be watched by a 'suitable guardian' nor is a simple bike lock likely to deter a thief, making it a 'suitable target'. Overall, our main hypothesis that *bike thefts occur primarily near train and tube stations * is perhaps not quite proven, but so far we have managed to quantify that a substantial amount of bike thefts do occur within 400m of these areas. -->
<!-- In a final step, we will conduct a very familiar procedure: aggregating our data to the ward level. At the moment, we have now calculated for each bike theft whether or not it occurs within 400m of a tube or train station. We can use this to see if specific wards are **hotspots** of bike crimes near stations across London. To do this, we will be using the same process we used in QGIS: counting **the number of points in each of our polygons**, i.e. the number of bike thefts in each ward. -->
<!-- To create a point-in-polygon count within `sf`, we use the `st_intersects()` function again but instead of using the matrix output of `TRUE` or `FALSE` that we have used before, what we actually want to extract from our function is the total number of points it identifies as intersecting with our `london_ward_shp` spatial dataframe. To achieve this, we use the `lengths()` function from the `base` R package to count the number of wards returned within the index list its `sparse` output creates.  -->
<!-- Remember, this `sparse` output creates a list of the bike thefts (by their index) that intersect with each ward. The `lengths()` function will return the length of this list, i.e. how many bike thefts each ward contains or, in other words, a **point-in-polygon** count. This time around therefore we do not set the `sparse` function to `FALSE` but leave it as `TRUE` (its default) by not entering the parameter. As a result, we can calculate the number of bike thefts per ward and the number of bike thefts within 400m of a station per ward and use this to generate a **theft rate** for each ward of the number of bikes thefts that occur near a train station for identification of these **hotspots**. -->
<!-- Calculate the number of bike thefts per ward and the number of bike thefts within 400m of a station per ward using the PIP operation via `st_intersects()`: -->
<!-- ```{r 06-intersect-test-2, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE} -->
<!-- # run a point-in-polygon analysis for total number of bike thefts within a ward using st_intersects function -->
<!-- london_ward_shp$total_bike_theft <- lengths(st_intersects(london_ward_shp, bike_theft_2019)) -->
<!-- # run a point-in-polygon analysis for number of bike thefts within 400m of train station within a ward using st_intersects function -->
<!-- london_ward_shp$nr_station_bike_theft <- lengths(st_intersects(london_ward_shp, filter(bike_theft_2019, nr_train_400 == TRUE))) -->
<!-- ``` -->
<!-- As you can see from the code above, we have now calculated our total bike theft and bike theft near a train station for each ward. The final step in our processing therefore is to create our rate of potentially station-related bike theft = bike theft near train station / total bike theft. -->
<!-- :::note -->
<!-- **Note** <br /> -->
<!-- We are looking specifically at the phenomena of whether bike theft occurs near to a train or tube station or not. By normalising by the total bike theft, we are creating a rate that shows specifically where there are hotspots of bike theft near train stations. This, however, will be of course influenced by the number of train stations within a ward, the size of the ward, and of course the number of bikes and potentially daytime and residential populations within an area. -->
<!-- ::: -->
<!-- Calculate the rate of bike theft within 400m of a train or tube station out of all bike thefts for each ward: -->
<!-- ```{r 06-rate-calc, warnings=FALSE, message=FALSE, cache=TRUE, tidy=TRUE} -->
<!-- # calculate the rate of bike thefts within 400m of train or tube station -->
<!-- london_ward_shp$btns_rate <- (london_ward_shp$nr_station_bike_theft/london_ward_shp$total_bike_theft)*100 -->
<!-- ``` -->
<!-- ## Assignment {#assignment-w06} -->
<!-- Now we worked through all this, for this week's assignment: -->
<!-- 1. Create a proper map of the rate of bike thefts within **400m** of a train or tube station. -->
<!-- 2. Re-run the above analysis at four more distances: **100m**, **200m**, **300m**, **500m** and calculate the percentage of bike theft at these different distances. You can choose whether you would like to use the **geometric operations** or **spatial queries** approach. What do you think could explain the substantial differences in counts as we increase away from the train station from 100 to 200m? -->
<!-- ## Before you leave {#byl-w06} -->
<!-- And that is how you can conduct basic geometric operations and spatial queries using R and `sf`. Of course: more RGIS in the coming weeks, but [this concludes the tutorial for this week](https://www.youtube.com/watch?v=Ydg4T2MP7Z8). -->


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./05-spatial.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Programming for Spatial Analysis</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./11-data.html" class="pagination-link">
        <span class="nav-page-text">Data Sources</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">Course material by <a href="https://www.mappingdutchman.com">Justin van Dijk</a>. Available under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>



<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>